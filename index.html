<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="夏天这么热能把暗恋变成热恋嘛">
<meta property="og:type" content="website">
<meta property="og:title" content="张小二的笔记本">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="张小二的笔记本">
<meta property="og:description" content="夏天这么热能把暗恋变成热恋嘛">
<meta property="og:locale">
<meta property="article:author" content="张小二">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>张小二的笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张小二的笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/%E5%88%A9%E7%94%A8JMeter%E5%AF%B9SpringBoot-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/%E5%88%A9%E7%94%A8JMeter%E5%AF%B9SpringBoot-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B/" class="post-title-link" itemprop="url">利用JMeter对SpringBoot 同步与异步请求进行压测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-02 11:37:49" itemprop="dateCreated datePublished" datetime="2021-07-02T11:37:49+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:48:01" itemprop="dateModified" datetime="2022-07-16T11:48:01+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>引用一段书本里面的话来简单介绍一下同步与异步</p>
<blockquote>
<p>同步, 可以理解为在执行完一个函数或方法之后, 一直等待系统返回值或消息, 这时程序是出于阻塞的, 只有接收到返回的值或消息后才往下执行其他的命令.</p>
</blockquote>
<blockquote>
<p>异步, 执行完函数或方法后, 不必阻塞性地等待返回值或消息, 只需要向系统委托一个异步过程, 那么当系统接收到返回值或消息时, 系统会自动触发委托的异步过程, 从而完成一个完整的流程.</p>
</blockquote>
<h3 id="Spring-Web工程中的异步"><a href="#Spring-Web工程中的异步" class="headerlink" title="Spring Web工程中的异步"></a>Spring Web工程中的异步</h3><p>Spring的Web工程原生也支持了异步编程<br>Spring提供了DeferredResult类与@Asycn注解来支持两种不同的异步编程模式</p>
<h4 id="BaseResult返回结构体"><a href="#BaseResult返回结构体" class="headerlink" title="BaseResult返回结构体"></a>BaseResult返回结构体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class BaseResult&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; BaseResult&lt;T&gt; success(T obj) &#123;</span><br><span class="line">        BaseResult&lt;T&gt; baseResult = new BaseResult&lt;&gt;();</span><br><span class="line">        baseResult.setCode(ResultEnum.SUCCESS.getCode());</span><br><span class="line">        baseResult.setMsg(ResultEnum.SUCCESS.getMsg());</span><br><span class="line">        baseResult.setData(obj);</span><br><span class="line">        return baseResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; BaseResult&lt;T&gt; success() &#123;</span><br><span class="line">        return success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; BaseResult&lt;T&gt; error(Integer code, String msg) &#123;</span><br><span class="line">        BaseResult&lt;T&gt; baseResult = new BaseResult&lt;&gt;();</span><br><span class="line">        baseResult.setCode(code);</span><br><span class="line">        baseResult.setMsg(msg);</span><br><span class="line">        baseResult.setData(null);</span><br><span class="line">        return baseResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a>DeferredResult</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/deferredResultAsync&quot;)</span><br><span class="line">public DeferredResult&lt;BaseResult&lt;String&gt;&gt; deferredResultAsync(@RequestParam(required = false, defaultValue = &quot;false&quot;) boolean isCpuTask) &#123;</span><br><span class="line">    DeferredResult&lt;BaseResult&lt;String&gt;&gt; deferredResult = new DeferredResult&lt;&gt;();</span><br><span class="line">    executors.submit(() -&gt; deferredResult.setResult(benchmarkService.mockTask(&quot;deferredResultAsync&quot;, isCpuTask)));</span><br><span class="line">    return deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Async注解"><a href="#Async注解" class="headerlink" title="@Async注解"></a>@Async注解</h4><p>需要在Configuration或Boot类上加上@EnableAsync注解, 以开启异步注解的支持<br>Controller方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/listenableFutureAsync&quot;)</span><br><span class="line">public ListenableFuture&lt;BaseResult&lt;String&gt;&gt; listenableFutureAsync(@RequestParam(required = false, defaultValue = &quot;false&quot;) boolean isCpuTask) &#123;</span><br><span class="line">    return benchmarkService.listenableFutureAsync(isCpuTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line">public ListenableFuture&lt;BaseResult&lt;String&gt;&gt; listenableFutureAsync(boolean isCpuTask) &#123;</span><br><span class="line">    return AsyncResult.forValue(mockTask(&quot;listenableFutureAsync&quot;, isCpuTask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h3><h4 id="IO密集型任务"><a href="#IO密集型任务" class="headerlink" title="IO密集型任务"></a>IO密集型任务</h4><p>IO密集型任务指的是那些耗用IO的操作, 比如文件读写, 读取外部数据库, 调用外部接口等, 过程是阻塞的<br>下面来模拟调用外部接口来mock一个IO密集型任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private BaseResult&lt;String&gt; mockIOTask(String mark) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(benchmarkTaskTime);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">        LOGGER.error(&quot;Mock IO Task Error&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return BaseResult.success(mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cpu密集型任务"><a href="#Cpu密集型任务" class="headerlink" title="Cpu密集型任务"></a>Cpu密集型任务</h4><p>Cpu密集型任务指的是那些需要操作Cpu进行一定数据计算的任务, 比如加减乘除, 去重, 词序统计, 排序等<br>下面通过一段for循环计算来mock一个Cpu密集型任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private BaseResult&lt;String&gt; mockCpuTask(String mark) &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int firstCycle = 500;</span><br><span class="line">    int secondCycle = firstCycle * 100;</span><br><span class="line">    for (int i = 0; i &lt; firstCycle; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; secondCycle; j++) &#123;</span><br><span class="line">            num += i * j;</span><br><span class="line">            if (num &gt; 10000) &#123;</span><br><span class="line">                num += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 欺骗编译器, 防止优化, 因为前面的代码计算的数据都没有被依赖</span><br><span class="line">    LOGGER.debug(&quot;num:&#123;&#125;&quot;, num);</span><br><span class="line">    return BaseResult.success(mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO和Cpu都耗用的任务"><a href="#IO和Cpu都耗用的任务" class="headerlink" title="IO和Cpu都耗用的任务"></a>IO和Cpu都耗用的任务</h4><p>IO和Cpu都耗用的任务类似于那些从数据库中取出数据, 然后进行计算操作的场景</p>
<p>下面通过时间差来mock一个IO和Cpu都耗用的任务  </p>
<ol>
<li>该方法执行100ms左右, 不会去极限压榨cpu, 只是会让线程计算benchmarkTaskTime的时间  </li>
<li>但是这个时间也算上了不被分配cpu的时间, 不是纯cpu计算的时间  </li>
<li>可以用来模拟即耗用io, 也耗用cpu的任务  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private BaseResult&lt;String&gt; mockIOAndCpuTask(String mark) &#123;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    // 占同cpu benchmarkTaskTime ms</span><br><span class="line">    while ((System.currentTimeMillis() - startTime) &lt;= benchmarkTaskTime) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(UUID.randomUUID().toString(), UUID.randomUUID().toString());</span><br><span class="line">        map.put(UUID.randomUUID().toString(), UUID.randomUUID().toString());</span><br><span class="line">        // 欺骗编译器, 不输出到控制台</span><br><span class="line">        // 防止因为后续的代码不对前面造成依赖, 而导致被优化</span><br><span class="line">        LOGGER.debug(JsonUtils.toJson(map));</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(&quot;Cpu Task Mark:&#123;&#125;&quot;, mark);</span><br><span class="line">    return BaseResult.success(mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><ul>
<li>Cpu  i5-9400 6c6t</li>
<li>内存 16GB  </li>
<li>操作系统 mac OS Mojave 10.14.5</li>
</ul>
<p>笔者是在本地使用JMeter对本地的SpringBoot进程进行压测的, 测试结果可能受到影响, 但也能在一定程度上反映问题</p>
<h3 id="JMeter压测参数"><a href="#JMeter压测参数" class="headerlink" title="JMeter压测参数"></a>JMeter压测参数</h3><p>todo</p>
<h3 id="JMeter压测结果"><a href="#JMeter压测结果" class="headerlink" title="JMeter压测结果"></a>JMeter压测结果</h3><p>todo</p>
<h4 id="Tomcat线程数500-压测结果"><a href="#Tomcat线程数500-压测结果" class="headerlink" title="Tomcat线程数500 压测结果"></a>Tomcat线程数500 压测结果</h4><p>todo</p>
<h4 id="Tomcat线程数1000-压测结果"><a href="#Tomcat线程数1000-压测结果" class="headerlink" title="Tomcat线程数1000 压测结果"></a>Tomcat线程数1000 压测结果</h4><p>todo</p>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>todo</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/28/%E4%BD%BF%E7%94%A8%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AF%B9ReentrantLock%E7%9A%84%E5%85%AC%E5%B9%B3%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/%E4%BD%BF%E7%94%A8%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AF%B9ReentrantLock%E7%9A%84%E5%85%AC%E5%B9%B3%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">使用微基准测试框架对ReentrantLock的公平与非公平锁进行性能测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-28 11:37:21" itemprop="dateCreated datePublished" datetime="2021-05-28T11:37:21+08:00">2021-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:46:34" itemprop="dateModified" datetime="2022-07-16T11:46:34+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在阅读ReentrantLock源码的时候, 发现了Lock有公平和不公平两种锁, 查阅相关资料与博客后得知公平锁和非公平锁的性能是不一样的, 非公平锁的性能会优于公平锁.<br>因为FairLock在获取锁时, 永远是等待时间最长的线程获取到锁, 这样当线程释放锁以后, 如果还想继续再获取锁, 就必须去Sync队列尾部进行排队, 这样就会发生频繁的线程切换, 所以非公平锁的吞吐量就要强于公平锁</p>
<h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><p>是openjdk提供一种基准测试的框架, 支持多种粒度的性能测试. 官方文档: <a target="_blank" rel="noopener" href="https://github.com/openjdk/jmh">https://github.com/openjdk/jmh</a></p>
<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JMH--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="性能测试代码"><a href="#性能测试代码" class="headerlink" title="性能测试代码"></a>性能测试代码</h1><p>利用CountDownLatch配合JMH, 测试极端条件下(获取锁之后立马释放锁, 不断循环), 不同的线程数量循环10000次加锁解锁的平均时间  </p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a target="_blank" rel="noopener" href="https://github.com/plum-wine/code-commons/blob/master/api/src/main/java/com/github/thread/BenchmarkFairAndNonFair.java">https://github.com/plum-wine/code-commons/blob/master/api/src/main/java/com/github/thread/BenchmarkFairAndNonFair.java</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Fork(1)</span><br><span class="line">@Threads(1)</span><br><span class="line">@Warmup(iterations = 1)</span><br><span class="line">@State(Scope.Benchmark)</span><br><span class="line">@BenchmarkMode(Mode.AverageTime)</span><br><span class="line">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span><br><span class="line">@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)</span><br><span class="line">public class BenchmarkFairAndNonFair &#123;</span><br><span class="line"></span><br><span class="line">    @Param(&#123;&quot;10&quot;, &quot;50&quot;, &quot;100&quot;, &quot;300&quot;, &quot;500&quot;&#125;)</span><br><span class="line">    private int threadNum;</span><br><span class="line"></span><br><span class="line">    private static final int FOREACH_COUNT = 10000;</span><br><span class="line"></span><br><span class="line">    @Benchmark</span><br><span class="line">    public void testFairLock() throws InterruptedException &#123;</span><br><span class="line">        final Lock fairLock = new ReentrantLock(true);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadNum);</span><br><span class="line">        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; threadNum; i++) &#123;</span><br><span class="line">            threads.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; FOREACH_COUNT; j++) &#123;</span><br><span class="line">                    fairLock.lock();</span><br><span class="line">                    fairLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        threads.forEach(thread -&gt; thread.start());</span><br><span class="line">        // main wait all thread</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Benchmark</span><br><span class="line">    public void testNonFairLock() throws InterruptedException &#123;</span><br><span class="line">        final Lock nonFairLock = new ReentrantLock(false);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadNum);</span><br><span class="line">        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; threadNum; i++) &#123;</span><br><span class="line">            threads.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; FOREACH_COUNT; j++) &#123;</span><br><span class="line">                    nonFairLock.lock();</span><br><span class="line">                    nonFairLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        threads.forEach(thread -&gt; thread.start());</span><br><span class="line">        // main wait all thread</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws RunnerException &#123;</span><br><span class="line">        Options options = new OptionsBuilder()</span><br><span class="line">                .include(BenchmarkFairAndNonFair.class.getSimpleName())</span><br><span class="line">                .build();</span><br><span class="line">        new Runner(options).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="性能测试结果"><a href="#性能测试结果" class="headerlink" title="性能测试结果"></a>性能测试结果</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:08:23</span><br><span class="line"></span><br><span class="line">Benchmark                                (threadNum)  Mode  Cnt      Score      Error  Units</span><br><span class="line">BenchmarkFairAndNonFair.testFairLock              10  avgt    5    335.780 ±   13.599  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testFairLock              50  avgt    5   1856.063 ±  127.977  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testFairLock             100  avgt    5   3917.435 ±  673.222  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testFairLock             300  avgt    5  14387.132 ± 3668.159  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testFairLock             500  avgt    5  29424.262 ± 2485.551  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testNonFairLock           10  avgt    5      2.383 ±    0.094  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testNonFairLock           50  avgt    5     11.402 ±    0.820  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testNonFairLock          100  avgt    5     23.525 ±    1.628  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testNonFairLock          300  avgt    5     70.299 ±    0.746  ms/op</span><br><span class="line">BenchmarkFairAndNonFair.testNonFairLock          500  avgt    5    121.046 ±    2.014  ms/op</span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>从测试结果可以可看出, 非公平锁的性能确实比公平锁要好, 而且线程数量越多, 差别越是明显</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor-%E5%8A%A0%E8%BD%BD%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor-%E5%8A%A0%E8%BD%BD%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">线程池 ThreadPoolExecutor 加载任务的流程以及复用线程的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-19 11:39:25" itemprop="dateCreated datePublished" datetime="2021-04-19T11:39:25+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:46:19" itemprop="dateModified" datetime="2022-07-16T11:46:19+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>老生常谈的总结一下线程池的一些相关参数以及对应的处理逻辑, 总结线程池的相关原理</p>
<h1 id="线程池参数以及任务处理流程"><a href="#线程池参数以及任务处理流程" class="headerlink" title="线程池参数以及任务处理流程"></a>线程池参数以及任务处理流程</h1><h2 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h2><ol>
<li>避免了反复创建销毁线程带来的开销, 统一管理</li>
<li>控制线程数量, 合理统筹计算资源(保持小的线程数量, 负载变大时才增加线程数量)</li>
<li>加快响应</li>
</ol>
<h2 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h2><ol>
<li>coreSize: 核心线程池数量</li>
<li>maxPoolSize: 最大线程池数量</li>
<li>keepAliveTime: 核心线程池之外的线程的存活时间</li>
<li>timeUnit: 时间单位</li>
<li>blockingQueue: 阻塞队列</li>
<li>threadFactory: 线程池</li>
<li>rejectHandler: 拒绝策略</li>
</ol>
<h2 id="任务处理流程"><a href="#任务处理流程" class="headerlink" title="任务处理流程"></a>任务处理流程</h2><ol>
<li>首先检测线程池运行状态,如果不是RUNNING,则直接拒绝,线程池要保证在RUNNING的状态下执行任务.</li>
<li>如果workerCount &lt; corePoolSize,则创建并启动一个线程来执行新提交的任务.</li>
<li>如果workerCount &gt;&#x3D; corePoolSize,且线程池内的阻塞队列未满,则将任务添加到该阻塞队列中.</li>
<li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize,且线程池内的阻塞队列已满,则创建并启动一个线程来执行新提交的任务.</li>
<li>如果workerCount &gt;&#x3D; maximumPoolSize,并且线程池内的阻塞队列已满,,则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常.</li>
</ol>
<h2 id="线程池的几种拒绝策略以及缓冲队列"><a href="#线程池的几种拒绝策略以及缓冲队列" class="headerlink" title="线程池的几种拒绝策略以及缓冲队列"></a>线程池的几种拒绝策略以及缓冲队列</h2><ul>
<li>缓冲队列<ul>
<li>ArrayBlockQueue: 数组实现的有界阻塞队列,先进先出</li>
<li>LinkedBlockQueue: 链表实现的无界阻塞队列,默认长度Integer.MAX_VALUE</li>
<li>PriorityBlockQueue: 支持优先级的无界队列,默认自然排序,可以实现compareTo方法</li>
<li>DelayQueue: 延迟获取无界队列</li>
<li>SychronousQueue: 不存储元素的队列</li>
<li>LinkedBlockDeque: 由链表组成的双向队列,多线程并发时,可以将锁的竞争降低到一半</li>
</ul>
</li>
<li>任务拒绝<ul>
<li>AbortPolicy: 丢弃任务并抛出RejectExecutionException</li>
<li>DiscardPolicy: 丢弃任务,不抛出异常. 适合无关紧要的任务</li>
<li>DiscardOldPolicy: 丢弃队列最前面的任务,然后重新提交任务</li>
<li>CallerRunPolicy: 由调用线程执行任务. 适合于必须让任务执行完的场景,多线程只是增加吞吐</li>
</ul>
</li>
</ul>
<h2 id="JDK自带的几种自动创建的线程池"><a href="#JDK自带的几种自动创建的线程池" class="headerlink" title="JDK自带的几种自动创建的线程池"></a>JDK自带的几种自动创建的线程池</h2><ol>
<li>Executors.newFixedThreadPool();<ol>
<li>LinkedBlockingQueue, 无界队列</li>
<li>线程数量固定</li>
</ol>
</li>
<li>Executors.newSingleThreadExecutor();<ol>
<li>LinkedBlockingQueue, 无界队列</li>
<li>线程数量只有一个</li>
</ol>
</li>
<li>Executors.newCachedThreadExecutor();<ol>
<li>SychronousQueue, 不存储元素, 直接交换的队列</li>
<li>coreSize为0, maxPoolSize为Integer.MAX_VALUE</li>
</ol>
</li>
<li>Executors.newScheduledThreadExecutor();<ol>
<li>支持周期性任务</li>
</ol>
</li>
</ol>
<h1 id="线程数量的选择"><a href="#线程数量的选择" class="headerlink" title="线程数量的选择"></a>线程数量的选择</h1><ol>
<li>Cpu密集型: 设置为Cpu核心数量的两倍</li>
<li>耗时IO型: 设置为Cpu核心数的多倍, 比如10倍</li>
<li>有一个计算公式: Cpu核心数*(1+平均等待时间&#x2F;平均工作时间)</li>
<li>其实线程池数量的选择不能完全依赖上述的几点, 还需要结合机器资源进行压力测试, 那样才是最优的</li>
</ol>
<h1 id="与线程池的停止有关的几个方法"><a href="#与线程池的停止有关的几个方法" class="headerlink" title="与线程池的停止有关的几个方法"></a>与线程池的停止有关的几个方法</h1><ol>
<li>shutdown<br> 并不一定会停止, 需要等待正在运行的任务执行完毕. 同时不再接收新的任务</li>
<li>shutdownNow<br> 发出Interrupt信号, 停止提交了, 但是还没有运行的任务. 并返回还未开始执行的任务</li>
<li>isShutdown<br> 判断线程池是否停止</li>
<li>isTerminated<br> 当前线程池是否已经停止并且执行完了所有任务</li>
<li>awaitTerminated(timeout, unit)<br> 线程池任务全部完毕之后返回true, 或者timeout之后返回false</li>
</ol>
<h1 id="线程池参数动态化"><a href="#线程池参数动态化" class="headerlink" title="线程池参数动态化"></a>线程池参数动态化</h1><ul>
<li>参数动态化<ul>
<li>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略</li>
<li>支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效</li>
</ul>
</li>
<li>线程池监控<ul>
<li>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数</li>
<li>线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息</li>
<li>负载告警<ul>
<li>线程池负载数达到一定阈值: activeCount&#x2F;maximumPoolSize</li>
<li>线程池队列任务积压</li>
<li>一个是发生了Reject异常,一个是队列中有等待任务</li>
</ul>
</li>
<li>操作监控: 创建&#x2F;修改和删除线程池都会通知</li>
</ul>
</li>
</ul>
<h1 id="线程池是如何复用线程的"><a href="#线程池是如何复用线程的" class="headerlink" title="线程池是如何复用线程的"></a>线程池是如何复用线程的</h1><p>线程run方法中有一个while循环,如果是核心线程,会不断轮训.如果是非核心线程,会利用阻塞队列的poll超时返回机制,一旦超过就回收线程</p>
<h1 id="线程池中的任务抛出异常后如何处理"><a href="#线程池中的任务抛出异常后如何处理" class="headerlink" title="线程池中的任务抛出异常后如何处理"></a>线程池中的任务抛出异常后如何处理</h1><p>抛出异常后,线程池会回收该线程,同时将工作线程数减一</p>
<h1 id="线程池相关源码"><a href="#线程池相关源码" class="headerlink" title="线程池相关源码"></a>线程池相关源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">// AbstractExecutorService</span><br><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    // </span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ThreadPoolService</span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    /*</span><br><span class="line">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span><br><span class="line">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span><br><span class="line">     * 并把任务添加到该线程中。</span><br><span class="line">     */</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span><br><span class="line">    // 这时需要移除该command</span><br><span class="line">    // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        </span><br><span class="line">        // 获取线程池中的有效线程数,如果数量是0,则执行addWorker方法</span><br><span class="line">        // 这里传入的参数表示:</span><br><span class="line">        // 1. 第一个参数为null,表示在线程池中创建一个线程,但不去启动.</span><br><span class="line">        // 2. 第二个参数为false,将线程池的有限线程数量的上限设置为maximumPoolSize,添加线程时根据maximumPoolSize来判断.</span><br><span class="line">        // 如果判断workerCount大于0,则直接返回,在workQueue中新增的command会在将来的某个时刻被执行.</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 如果执行到这里，有两种情况：</span><br><span class="line">     * 1. 线程池已经不是RUNNING状态；</span><br><span class="line">     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span><br><span class="line">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span><br><span class="line">     * 如果失败则拒绝该任务</span><br><span class="line">     */</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加到执行队列</span><br><span class="line">// 当firstTask不为null时,表示提交到核心线程区域</span><br><span class="line">// 当firstTask为null时,表示提交到非核心区域</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 利用一个AtomicInteger来保存两个状态</span><br><span class="line">        // 线程池运行状态,线程池任务数量</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        // 通过位运算获取</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         * 这个if判断</span><br><span class="line">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span><br><span class="line">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</span><br><span class="line">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span><br><span class="line">         * 2. firsTask为空</span><br><span class="line">         * 3. 阻塞队列不为空</span><br><span class="line">         * </span><br><span class="line">         * 首先考虑rs == SHUTDOWN的情况</span><br><span class="line">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span><br><span class="line">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span><br><span class="line">         * 因为队列中已经没有任务了，不需要再添加线程了</span><br><span class="line">         */</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 完成线程初始化</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            // 这个习惯用法也与CPU缓存有关</span><br><span class="line">            // 从栈读变量比从堆读变量会更cache-friendly,本地变量最终绑定到CPU寄存器的可能性更高</span><br><span class="line">            // addWorker的时候需要加锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // Recheck while holding lock.</span><br><span class="line">                // Back out on ThreadFactory failure or if</span><br><span class="line">                // shut down before lock acquired.</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                // 线程池没有停止,或者当前任务是提交到非核心区域</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    // 持有引用</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    // 更新最大数量</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 启动线程</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h1><p>Worker工作线程,实现了Runnable接口,并持有一个线程thread,一个初始化的任务firstTask.thread是在调用构造方法时通过ThreadFactory来创建的线程,可以用来执行任务;firstTask用它来保存传入的第一个任务,这个任务可以有也可以为null.如果这个值是非空的,那么线程就会在启动初期立即执行这个任务,也就对应核心线程创建时的情况;如果这个值是null,那么就需要创建一个线程去执行任务列表（workQueue）中的任务,也就是非核心线程的创建.</p>
<h1 id="Worker源码"><a href="#Worker源码" class="headerlink" title="Worker源码"></a>Worker源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * This class will never be serialized, but we provide a</span><br><span class="line">     * serialVersionUID to suppress a javac warning.</span><br><span class="line">     */</span><br><span class="line">    private static final long serialVersionUID = 6138294804551838833L;</span><br><span class="line"></span><br><span class="line">    /** Thread this worker is running in.  Null if factory fails. */</span><br><span class="line">    final Thread thread;</span><br><span class="line">    /** Initial task to run.  Possibly null. */</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    /** Per-thread task counter */</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="line">     * @param firstTask the first task (null if none)</span><br><span class="line">     */</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">        // 通过线程池创建thread,runnable参数就是this</span><br><span class="line">        this.thread = getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Delegates main run loop to outer runWorker  */</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        return getState() != 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 借助aqs实现不可重入</span><br><span class="line">    protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    protected boolean tryRelease(int unused) &#123;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        setState(0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">    // tryLock可以知道当前线程是否有任务在执行</span><br><span class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">    public void unlock()      &#123; release(1); &#125;</span><br><span class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    void interruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    // 是否因为异常退出循环</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // getTask()方法,不断轮询问</span><br><span class="line">        // getTask()返回null的时候,循环跳出</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            // 不可重入锁</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 任务的执行</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                // 更新线程池完成任务的数量</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 回收线程</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span><br><span class="line">         * 1. rs &gt;= STOP，线程池是否正在stop；</span><br><span class="line">         * 2. 阻塞队列是否为空。</span><br><span class="line">         * 如果以上条件满足，则将workerCount减1并返回null。</span><br><span class="line">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span><br><span class="line">         */</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // timed变量用于判断是否需要进行超时控制。</span><br><span class="line">        // allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span><br><span class="line">        // wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span><br><span class="line">        // 对于超过核心线程数量的这些线程，需要进行超时控制</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span><br><span class="line">             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span><br><span class="line">             */</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // 如果completedAbruptly值为true,则说明线程执行时出现了异常,需要将workerCount减1.</span><br><span class="line">    // 如果线程执行时没有出现异常,说明在getTask()方法中已经已经对workerCount进行了减1操作,这里就不必再减了.  </span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&#x27;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 统计完成的任务数</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        // 从workers中移除,也就表示着从线程池中移除了一个工作线程</span><br><span class="line">        // 同时失去对改线程的引用</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据线程池状态进行判断是否结束线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    /*</span><br><span class="line">     * 当线程池是RUNNING或SHUTDOWN状态时,如果worker是异常结束，那么会直接addWorker.</span><br><span class="line">     * 如果allowCoreThreadTimeOut=true,并且等待队列有任务，至少保留一个worker.</span><br><span class="line">     * 如果allowCoreThreadTimeOut=false,workerCount不少于corePoolSize.</span><br><span class="line">     */</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/CountDownLatch%E4%B8%8EAQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/CountDownLatch%E4%B8%8EAQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">CountDownLatch与AQS共享模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-18 11:37:05" itemprop="dateCreated datePublished" datetime="2021-04-18T11:37:05+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:46:08" itemprop="dateModified" datetime="2022-07-16T11:46:08+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上有很多通过分析ReentrantLock来讲解AQS独占模式的文章, 这里就不老生常谈的讲独占锁了, 本篇文章主要是分析CountDownLatch是如何利用AQS的共享模式来实现的倒计时门闩的功能</p>
<p>关于CountDownLatch以及相关线程协作工具类的用法可以参考之前写的一篇文章: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/plumswine/p/14118324.html">https://www.cnblogs.com/plumswine/p/14118324.html</a></p>
<p>关于ReentrantLock与AQS独占模式, 美团有一篇技术博客, 讲的很好: <a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>
<h1 id="CountDownLatch-API"><a href="#CountDownLatch-API" class="headerlink" title="CountDownLatch API"></a>CountDownLatch API</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CountDownLatch不能被重用, 如果需要重新计数, 可以考虑CyclicBarrier</span><br><span class="line"> * all wait for onw, 如多个运动员等待裁判员鸣枪, 比赛开始</span><br><span class="line"> * one wait for all, 如等待所有运动员到达终点, 比赛结束</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCountDownLatch() throws InterruptedException &#123;</span><br><span class="line">    int size = 10;</span><br><span class="line">    final CountDownLatch end = new CountDownLatch(size);</span><br><span class="line">    final CountDownLatch begin = new CountDownLatch(1);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 准备起跑&quot;, Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    begin.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 起跑&quot;, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 随机的跑步时间</span><br><span class="line">                    long time = Math.abs(new Random().nextInt(20));</span><br><span class="line">                    Thread.sleep(time);</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 到达终点&quot;, Thread.currentThread().getName());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                end.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(100L);</span><br><span class="line">    LOGGER.info(&quot;裁判员鸣枪, 比赛开始&quot;);</span><br><span class="line">    begin.countDown();</span><br><span class="line">    end.await();</span><br><span class="line">    LOGGER.info(&quot;所有运动员到达终点, 比赛结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">14:22:30.526 [pool-1-thread-3] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-3 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-4] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-4 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-7] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-7 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-10] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-10 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-1] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-1 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-5] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-5 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-2] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-2 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-6] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-6 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-9] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-9 准备起跑</span><br><span class="line">14:22:30.526 [pool-1-thread-8] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-8 准备起跑</span><br><span class="line">14:22:30.625 [main] INFO  c.g.thread.ThreadControlToolsTest - 裁判员鸣枪, 比赛开始</span><br><span class="line">14:22:30.625 [pool-1-thread-3] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-3 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-7] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-7 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-4] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-4 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-9] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-9 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-8] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-8 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-6] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-6 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-2] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-2 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-1] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-1 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-5] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-5 起跑</span><br><span class="line">14:22:30.626 [pool-1-thread-10] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-10 起跑</span><br><span class="line">14:22:30.629 [pool-1-thread-8] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-8 到达终点</span><br><span class="line">14:22:30.629 [pool-1-thread-4] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-4 到达终点</span><br><span class="line">14:22:30.632 [pool-1-thread-5] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-5 到达终点</span><br><span class="line">14:22:30.634 [pool-1-thread-2] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-2 到达终点</span><br><span class="line">14:22:30.634 [pool-1-thread-9] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-9 到达终点</span><br><span class="line">14:22:30.634 [pool-1-thread-7] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-7 到达终点</span><br><span class="line">14:22:30.637 [pool-1-thread-3] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-3 到达终点</span><br><span class="line">14:22:30.638 [pool-1-thread-6] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-6 到达终点</span><br><span class="line">14:22:30.642 [pool-1-thread-10] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-10 到达终点</span><br><span class="line">14:22:30.648 [pool-1-thread-1] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-1 到达终点</span><br><span class="line">14:22:30.648 [main] INFO  c.g.thread.ThreadControlToolsTest - 所有运动员到达终点, 比赛结束</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="CountDownLatch源码"><a href="#CountDownLatch源码" class="headerlink" title="CountDownLatch源码"></a>CountDownLatch源码</h1><p>CountDownLatch的源码行数很少, 就几十行, 这主要是归功于AQS提供的并发框架, 子类只需要实现模板方法就可以完成所需要的功能, 其实基于AQS方法实现的线程工具类都有一个特点, 就是构建一个内部类Sync去继承AQS类, 再内部持有一个sync对象, 通过这个sync对象来操作有volatile修饰的state实现线程协作</p>
<p>源码解析见注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatch &#123;</span><br><span class="line"></span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        // Sync对象建立时就初始化state</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getCount() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line">        // 被AQS回调, 当返回小于0的值时, 会进入阻塞阶段</span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过cas将state减1</span><br><span class="line">        // 被AQS回调, 当返回true时, 唤醒被阻塞的线程</span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            // Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">                if (c == 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final Sync sync;</span><br><span class="line"></span><br><span class="line">    // 下面的方法都是直接暴露给外部直接调用的</span><br><span class="line"></span><br><span class="line">    public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // acquireSharedInterruptibly这个方法是在AQS中定义的</span><br><span class="line">    // 该方法中定义了一套模板, 核心逻辑是Sync中的tryAcquireShared方法</span><br><span class="line">    // AQS根据tryAcquireShared不同的返回值执行不同的操作</span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 与await类似, 都是直接调用AQS的定义的模板, 核心逻辑是Sync中的tryReleaseShared方法</span><br><span class="line">    // AQS根据tryReleaseShared不同的返回值执行不同的操作</span><br><span class="line">    // 当countDown将state减到0时, 唤醒await的线程</span><br><span class="line">    public void countDown() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getCount() &#123;</span><br><span class="line">        return sync.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AbstractQueuedSynchronizer共享模式相关源码"><a href="#AbstractQueuedSynchronizer共享模式相关源码" class="headerlink" title="AbstractQueuedSynchronizer共享模式相关源码"></a>AbstractQueuedSynchronizer共享模式相关源码</h1><p>AQS的源码有很多, 本篇文章只关心与共享模式有关的代码</p>
<h2 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h2><p>该方法是被Sync直接操作的方法, 也就是AQS定义的模板流程, 子类通过实现tryAcquireShared方法来实现流程控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    // 这就是上文中提到的两个模板方法, 由子类实现</span><br><span class="line">    protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 共享模式释放state的方法, 基于的模板方法模式实现</span><br><span class="line">    // 该方法也就是工具类调用内部的Sync对象操作的方法</span><br><span class="line">    public final void acquireShared(int arg) &#123;</span><br><span class="line">        // 当子类实现的方法返回的值小于0时, 进入阻塞流程(入队列)</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void doAcquireShared(int arg) &#123;</span><br><span class="line">        // 构建节点, 并加入到双向队列中</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // 前驱节点是头结点, 再次尝试获取</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        if (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 这里是阻塞的地方, 其实就是调用LockSupport类的park方法将线程阻塞</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 支持响应中断, 主流程与上述代码一致</span><br><span class="line">    public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入队列过程"><a href="#入队列过程" class="headerlink" title="入队列过程"></a>入队列过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    </span><br><span class="line">    // 当tail节点为null时, 表示当前队列还一个元素都没有</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // cas设置tail节点, 成功则直接返回</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    // cas自旋设置tail</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><p>与tryAcquireShared的作用正好相反, 是释放共享state的过程, 详细代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 当Sync子类定义的tryReleaseShared返回true时, 开始唤醒队列中等待的元素</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 从头结点开始遍历队列</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                // cas成功之后才能去唤醒, 防止并发</span><br><span class="line">                // 这里的cas成功其实就是拿到唤醒的执行权限</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                // 本质是调用LockSupport的unpark方法</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/16/Groovy%E6%9E%84%E5%BB%BA%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/16/Groovy%E6%9E%84%E5%BB%BA%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">Groovy构建规则引擎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-16 11:36:53" itemprop="dateCreated datePublished" datetime="2021-03-16T11:36:53+08:00">2021-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:45:26" itemprop="dateModified" datetime="2022-07-16T11:45:26+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="Groovy模板引擎-API-构建动态脚本"><a href="#Groovy模板引擎-API-构建动态脚本" class="headerlink" title="Groovy模板引擎 API 构建动态脚本"></a>Groovy模板引擎 API 构建动态脚本</h1><p>可以利用Groovy提供的模板引擎, 在代码中编写脚本, 来完成一些动态化的需求, 案例如下, 当字符串长度等于4时, 执行打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class RuleEngine &#123;</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentHashMap&lt;String, Template&gt; SCRIPT_CACHE = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private static final SimpleTemplateEngine ENGINE = new SimpleTemplateEngine();</span><br><span class="line"></span><br><span class="line">    private static final String CONDITION_STR_TEMPLATE = &quot;$&#123;%s ? true : false&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    private static final String EXECUTE_STR_TEMPLATE = &quot;$&#123;%s&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String request = &quot;data&quot;;</span><br><span class="line">        String condition = &quot;request.length() == 4&quot;;</span><br><span class="line">        String execute = &quot;System.out.println(request)&quot;;</span><br><span class="line"></span><br><span class="line">        if (condition(condition, request)) &#123;</span><br><span class="line">            execute(execute, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean condition(String condition, String request) &#123;</span><br><span class="line">        boolean result;</span><br><span class="line">        String conditionTemplate = String.format(CONDITION_STR_TEMPLATE, condition);</span><br><span class="line">        Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();</span><br><span class="line">        context.put(&quot;request&quot;, request);</span><br><span class="line">        try &#123;</span><br><span class="line">            Template template;</span><br><span class="line">            if (SCRIPT_CACHE.containsKey(condition)) &#123;</span><br><span class="line">                template = SCRIPT_CACHE.get(condition);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                template = ENGINE.createTemplate(conditionTemplate);</span><br><span class="line">                SCRIPT_CACHE.put(condition, template);</span><br><span class="line">            &#125;</span><br><span class="line">            Writer writer = new StringWriter();</span><br><span class="line">            template.make(context).writeTo(writer);</span><br><span class="line">            result = Boolean.parseBoolean(writer.toString());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;模板解析异常&quot; + conditionTemplate);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void execute(String execute, String request) &#123;</span><br><span class="line">        String executeTemplate = String.format(EXECUTE_STR_TEMPLATE, execute);</span><br><span class="line">        Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();</span><br><span class="line">        context.put(&quot;request&quot;, request);</span><br><span class="line">        Template template;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (SCRIPT_CACHE.containsKey(execute)) &#123;</span><br><span class="line">                template = SCRIPT_CACHE.get(execute);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                template = ENGINE.createTemplate(executeTemplate);</span><br><span class="line">                SCRIPT_CACHE.put(execute, template);</span><br><span class="line">            &#125;</span><br><span class="line">            template.make(context).writeTo(new StringWriter());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;模板解析异常&quot; + executeTemplate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Groovy动态对象注册为Spring-IOC中的Bean"><a href="#Groovy动态对象注册为Spring-IOC中的Bean" class="headerlink" title="Groovy动态对象注册为Spring IOC中的Bean"></a>Groovy动态对象注册为Spring IOC中的Bean</h1><h2 id="groovy-script脚本"><a href="#groovy-script脚本" class="headerlink" title="groovy script脚本"></a>groovy script脚本</h2><p>内容如下, 与Java语法完全兼容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package groovy;</span><br><span class="line"></span><br><span class="line">import com.github.service.GroovyBeanCommand</span><br><span class="line">import org.slf4j.Logger</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line"></span><br><span class="line">import java.lang.invoke.MethodHandles;</span><br><span class="line"></span><br><span class="line">public class FoobarCommand implements GroovyBeanCommand &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String run() &#123;</span><br><span class="line">        LOGGER.info(&quot;foobar command&quot;);</span><br><span class="line">        return &quot;FoobarCommand Data&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约定的脚本所需实现的接口"><a href="#约定的脚本所需实现的接口" class="headerlink" title="约定的脚本所需实现的接口"></a>约定的脚本所需实现的接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GroovyBeanCommand &#123;</span><br><span class="line">    String run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部传入script的入口"><a href="#外部传入script的入口" class="headerlink" title="外部传入script的入口"></a>外部传入script的入口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/command/add&quot;)</span><br><span class="line">public void addGroovyCommand(@RequestParam String groovyBeanName, @RequestParam String script) &#123;</span><br><span class="line">    GroovyContextUtils.autowireBean(groovyBeanName, script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/command/run&quot;)</span><br><span class="line">public Object runGroovyCommand(@RequestParam String groovyBeanName) &#123;</span><br><span class="line">    GroovyBeanCommand command = GroovyContextUtils.getBean(groovyBeanName, GroovyBeanCommand.class);</span><br><span class="line">    return command.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将script注入到IOC中的工具类"><a href="#将script注入到IOC中的工具类" class="headerlink" title="将script注入到IOC中的工具类"></a>将script注入到IOC中的工具类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class GroovyContextUtils implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    private static final GroovyClassLoader CLASS_LOADER = new GroovyClassLoader();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(@NonNull ApplicationContext context) &#123;</span><br><span class="line">        applicationContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void autowireBean(String beanName, String script) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = CLASS_LOADER.parseClass(script);</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(clazz);</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionBuilder.getRawBeanDefinition();</span><br><span class="line">        beanDefinition.setScope(BeanDefinition.SCOPE_SINGLETON);</span><br><span class="line"></span><br><span class="line">        AutowireCapableBeanFactory autowireCapableBeanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">        autowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(beanDefinition, beanName);</span><br><span class="line"></span><br><span class="line">        BeanDefinitionRegistry beanRegistry = (BeanDefinitionRegistry) autowireCapableBeanFactory;</span><br><span class="line">        if (beanRegistry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            beanRegistry.removeBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        beanRegistry.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getBean(String beanName, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return applicationContext.getBean(beanName, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态脚本与规则编排"><a href="#动态脚本与规则编排" class="headerlink" title="动态脚本与规则编排"></a>动态脚本与规则编排</h1><p>自定义一套规则组, 将脚本编号保存, 按照所需要顺序组合起来, 实现规则的编排和可插拔, 并按照流程处理数据流</p>
<p>伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void process(Data data) &#123;</span><br><span class="line">    List&lt;Handler&gt; handlers = getHandlers(data.getBizCode());</span><br><span class="line">    for(Handler handler : handlers) &#123;</span><br><span class="line">        handler.run(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/JUC%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/JUC%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/" class="post-title-link" itemprop="url">JUC提供的几种线程之间协作的工具类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-22 11:36:39" itemprop="dateCreated datePublished" datetime="2021-02-22T11:36:39+08:00">2021-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:45:04" itemprop="dateModified" datetime="2022-07-16T11:45:04+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="CountDownLatch-倒计时门闩"><a href="#CountDownLatch-倒计时门闩" class="headerlink" title="CountDownLatch 倒计时门闩"></a>CountDownLatch 倒计时门闩</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CountDownLatch不能被重用, 如果需要重新计数, 可以考虑CyclicBarrier</span><br><span class="line"> * all wait for onw, 如多个运动员等待裁判员鸣枪, 比赛开始</span><br><span class="line"> * one wait for all, 如等待所有运动员到达终点, 比赛结束</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCountDownLatch() throws InterruptedException &#123;</span><br><span class="line">    int size = 10;</span><br><span class="line">    final CountDownLatch end = new CountDownLatch(size);</span><br><span class="line">    final CountDownLatch begin = new CountDownLatch(1);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 准备起跑&quot;, Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    begin.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 起跑&quot;, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 随机的跑步时间</span><br><span class="line">                    long time = Math.abs(new Random().nextInt(20));</span><br><span class="line">                    Thread.sleep(time);</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 到达终点&quot;, Thread.currentThread().getName());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                end.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(100L);</span><br><span class="line">    LOGGER.info(&quot;裁判员鸣枪, 比赛开始&quot;);</span><br><span class="line">    begin.countDown();</span><br><span class="line">    end.await();</span><br><span class="line">    LOGGER.info(&quot;所有运动员到达终点, 比赛结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="CyclicBarrier-循环珊栏"><a href="#CyclicBarrier-循环珊栏" class="headerlink" title="CyclicBarrier 循环珊栏"></a>CyclicBarrier 循环珊栏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 等待固定线程到达了珊栏位置, 所有线程才能继续向下执行</span><br><span class="line"> * 类似于在等待所有人都到齐后, 大家才开始讨论工作</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * CyclicBarrier的对象是一个一个的线程</span><br><span class="line"> * CountDownLatch则是一个又一个的事件</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCyclicBarrier() throws InterruptedException &#123;</span><br><span class="line">    int num = 3;</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(num);</span><br><span class="line">    LOGGER.info(&quot;等待第一次讨论&quot;);</span><br><span class="line">    for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">        Thread.sleep(100L);</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(300L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 到达&quot;, Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                // 三个线程统一在此处, 一起讨论工作</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 一起讨论工作&quot;, Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">    // 在使用完一次之后, 自动重用</span><br><span class="line">    LOGGER.info(&quot;等待第二次讨论&quot;);</span><br><span class="line">    for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">        Thread.sleep(100L);</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(300L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 到达&quot;, Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                // 三个线程统一在此处, 一起讨论工作</span><br><span class="line">                LOGGER.info(&quot;&#123;&#125; 一起讨论工作&quot;, Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">    // 除了自动重用之外, 还可以手动的reset</span><br><span class="line">    // cyclicBarrier.reset();</span><br><span class="line">    LOGGER.info(&quot;&#123;&#125; end&quot;, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSemaphore() throws InterruptedException &#123;</span><br><span class="line">    // true参数表示是否公平, 默认是非公平</span><br><span class="line">    final Semaphore semaphore = new Semaphore(3, true);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // acquire必须响应中断, 还有一种不需要响应中断的api</span><br><span class="line">                    // semaphore.acquireUninterruptibly();</span><br><span class="line">                    // acquire还支持传入int参数, 线程或者说任务可以根据权重拿到多个许可证</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    // 还可以try</span><br><span class="line">                    // semaphore.tryAcquire();</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 获取到许可证&quot;, Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(300L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(2000L);</span><br><span class="line">    LOGGER.info(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Condition-条件对象"><a href="#Condition-条件对象" class="headerlink" title="Condition 条件对象"></a>Condition 条件对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Condition的signal方法必须在持有锁的情况下才能执行</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCondition() throws InterruptedException &#123;</span><br><span class="line">    ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 开始等待, 释放锁&quot;, Thread.currentThread().getName());</span><br><span class="line">                    // await的时候释放锁, 醒来的时候则去争抢锁</span><br><span class="line">                    condition.await();</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 醒来, 获取到锁, 执行任务&quot;, Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(100L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 执行任务完毕, 释放锁&quot;, Thread.currentThread().getName());</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(200L);</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.signalAll();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(2000L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/LockSupport%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/LockSupport%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="post-title-link" itemprop="url">LockSupport注意事项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-17 11:40:02" itemprop="dateCreated datePublished" datetime="2021-02-17T11:40:02+08:00">2021-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:44:43" itemprop="dateModified" datetime="2022-07-16T11:44:43+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本以为LockSupport的park()方法会直接阻塞线程, 但是在阅读AQS源码的时候, 发现不是这个样子, 所以这里也记录一下LockSupport的park()方法的一些注意事项</p>
<h1 id="LockSupport-park"><a href="#LockSupport-park" class="headerlink" title="LockSupport.park()"></a>LockSupport.park()</h1><ol>
<li>功能: 阻塞当前线程</li>
<li>park方法只要线程设置了中断标志位,就直接返回,且不会清除中断标志位.</li>
<li>如下两个条件任何一个成立,park()都不会阻塞:<ol>
<li>中断标志位存在（wait,join,sleep或Thread.interrupted()都会清除中断标志位）</li>
<li>_counter为1（之前调用了unpark或者interrupt）</li>
</ol>
</li>
<li>sleep方法响应中断, 会修改标志位, 但是不会修改_counter</li>
<li>执行Thread.interrupted()会复位, 并且清空_counter</li>
</ol>
<h1 id="LockSupport-park-不阻塞的场景"><a href="#LockSupport-park-不阻塞的场景" class="headerlink" title="LockSupport.park() 不阻塞的场景"></a>LockSupport.park() 不阻塞的场景</h1><h2 id="线程被设置了中断标志位的情况下-park-方法不会阻塞"><a href="#线程被设置了中断标志位的情况下-park-方法不会阻塞" class="headerlink" title="线程被设置了中断标志位的情况下, park()方法不会阻塞"></a>线程被设置了中断标志位的情况下, park()方法不会阻塞</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void lockSupport3() throws InterruptedException &#123;</span><br><span class="line">    LOGGER.info(&quot;start&quot;);</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        LOGGER.info(&quot;thread start&quot;);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while ((System.currentTimeMillis() - start) &lt; 3L) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        LOGGER.info(&quot;thread end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    // 中断线程</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(5L);</span><br><span class="line">    LOGGER.info(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过响应sleep-中断异常-清除了中断标志位"><a href="#通过响应sleep-中断异常-清除了中断标志位" class="headerlink" title="通过响应sleep()中断异常, 清除了中断标志位"></a>通过响应sleep()中断异常, 清除了中断标志位</h2><p>响应sleep()方法的中断不会更改_counter, 所以park()还是不会阻塞线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 响应sleep()方法导致中断标志被清除, 但是LockSupport.park()方法还是不会阻塞</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void lockSupport() throws InterruptedException &#123;</span><br><span class="line">    final String mark = &quot;interrupt state:&#123;&#125;&quot;;</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        LOGGER.info(&quot;i`m start&quot;);</span><br><span class="line">        LOGGER.info(mark, Thread.currentThread().isInterrupted());</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // sleep()方法响应中断会清除标志位, 但是不会更改_counter</span><br><span class="line">            LOGGER.info(mark, Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(&quot;i`m work&quot;);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        LOGGER.info(mark, Thread.currentThread().isInterrupted());</span><br><span class="line">        LOGGER.info(&quot;i`m end&quot;);</span><br><span class="line">    &#125;, &quot;lockSupport&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    LOGGER.info(&quot;thread end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在unpark-方法之前执行了park-方法"><a href="#在unpark-方法之前执行了park-方法" class="headerlink" title="在unpark()方法之前执行了park()方法"></a>在unpark()方法之前执行了park()方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在park之前执行unpark()方法, 线程不会阻塞</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void lockSupport2() &#123;</span><br><span class="line">    LOGGER.info(&quot;start&quot;);</span><br><span class="line">    LockSupport.unpark(Thread.currentThread());</span><br><span class="line">    /*不会阻塞*/</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    LOGGER.info(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/13/RateLimiter-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/13/RateLimiter-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">RateLimiter 令牌桶限流算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-13 11:29:01" itemprop="dateCreated datePublished" datetime="2021-02-13T11:29:01+08:00">2021-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:44:23" itemprop="dateModified" datetime="2022-07-16T11:44:23+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">令牌桶算法简介</a></li>
<li><a href="#%E6%BA%90%E7%A0%81">源码</a><ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96smoothbursty">实例化SmoothBursty</a></li>
<li><a href="#smoothbursty%E5%B1%9E%E6%80%A7">SmoothBursty属性</a></li>
<li><a href="#smoothbursty">SmoothBursty</a><ul>
<li><a href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95resync">关键方法resync</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95">操作方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="令牌桶算法简介"><a href="#令牌桶算法简介" class="headerlink" title="令牌桶算法简介"></a>令牌桶算法简介</h1><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌, 而如果请求需要被处理, 则需要先从桶里获取一个令牌, 当桶里没有令牌可取时, 则拒绝服务.</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="实例化SmoothBursty"><a href="#实例化SmoothBursty" class="headerlink" title="实例化SmoothBursty"></a>实例化SmoothBursty</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static RateLimiter create(double permitsPerSecond) &#123;</span><br><span class="line">    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) &#123;</span><br><span class="line">    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    return rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SmoothBursty属性"><a href="#SmoothBursty属性" class="headerlink" title="SmoothBursty属性"></a>SmoothBursty属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当前存储令牌数</span><br><span class="line"> */</span><br><span class="line">double storedPermits;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最大存储令牌数</span><br><span class="line"> */</span><br><span class="line">double maxPermits;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加令牌时间间隔</span><br><span class="line"> */</span><br><span class="line">double stableIntervalMicros;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 下一次请求可以获取令牌的起始时间</span><br><span class="line"> * 由于RateLimiter允许预消费，上次请求预消费令牌后</span><br><span class="line"> * 下次请求需要等待相应的时间到nextFreeTicketMicros时刻才可以获取令牌</span><br><span class="line"> */</span><br><span class="line">private long nextFreeTicketMicros = 0L; // could be either in the past or future</span><br></pre></td></tr></table></figure>

<h2 id="SmoothBursty"><a href="#SmoothBursty" class="headerlink" title="SmoothBursty"></a>SmoothBursty</h2><h3 id="关键方法resync"><a href="#关键方法resync" class="headerlink" title="关键方法resync"></a>关键方法resync</h3><p>在每次获取令牌之前调用, 其实现思路为, 若当前时间晚于nextFreeTicketMicros, 则计算该段时间内可以生成多少令牌, 将生成的令牌加入令牌桶中并更新数据. 这样一来, 只需要在获取令牌时计算一次即可.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void resync(long nowMicros) &#123;</span><br><span class="line">    // if nextFreeTicket is in the past, resync to now</span><br><span class="line">    if (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">      double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">      // 不能超过令牌桶的size</span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">      nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">final long reserveEarliestAvailable(int requiredPermits, long nowMicros) &#123;</span><br><span class="line">    // 更新令牌桶中的数据</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    long returnValue = nextFreeTicketMicros;</span><br><span class="line">    // 不能超过最大限制</span><br><span class="line">    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);</span><br><span class="line">    // 预先消费的令牌桶数量</span><br><span class="line">    double freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">    long waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (long) (freshPermits * stableIntervalMicros);</span><br><span class="line">    // 更新nextFreeTicketMicros, 这里可能有预消费的情况, 所以需要重新算一次</span><br><span class="line">    this.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    // 更新令牌桶中的令牌数量</span><br><span class="line">    this.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    return returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/30/Semaphore%E4%B8%8EAQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/Semaphore%E4%B8%8EAQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Semaphore与AQS共享模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-30 11:38:39" itemprop="dateCreated datePublished" datetime="2021-01-30T11:38:39+08:00">2021-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:44:15" itemprop="dateModified" datetime="2022-07-16T11:44:15+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#semaphore-api">Semaphore API</a><ul>
<li><a href="#demo">Demo</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C">结果</a></li>
</ul>
</li>
<li><a href="#semaphore%E6%BA%90%E7%A0%81">Semaphore源码</a></li>
</ul>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章描述了CountDownLatch的实现以及AQS的共享模式, 本篇继续来看JUC包下的另外一个基于AQS共享模式实现的线程协作工具类Semaphore, 也就是Java信号量, 用于控制资源的并发访问量, 也就是线程数</p>
<h1 id="Semaphore-API"><a href="#Semaphore-API" class="headerlink" title="Semaphore API"></a>Semaphore API</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSemaphore() throws InterruptedException &#123;</span><br><span class="line">    // true参数表示是否公平, 默认是非公平</span><br><span class="line">    final Semaphore semaphore = new Semaphore(3, true);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        executors.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // acquire必须响应中断, 还有一种不需要响应中断的api</span><br><span class="line">                    // semaphore.acquireUninterruptibly();</span><br><span class="line">                    // acquire还支持传入int参数, 线程或者说任务可以根据权重拿到多个许可证</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    // 还可以try</span><br><span class="line">                    // semaphore.tryAcquire();</span><br><span class="line">                    LOGGER.info(&quot;&#123;&#125; 获取到许可证&quot;, Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(300L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(2000L);</span><br><span class="line">    LOGGER.info(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>从输出结果来看, 同一个时间点最多只有三个线程拿到了许可证, 也就是访问的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">14:43:34.450 [pool-1-thread-1] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-1 获取到许可证</span><br><span class="line">14:43:34.450 [pool-1-thread-3] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-3 获取到许可证</span><br><span class="line">14:43:34.450 [pool-1-thread-2] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-2 获取到许可证</span><br><span class="line">14:43:34.753 [pool-1-thread-4] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-4 获取到许可证</span><br><span class="line">14:43:34.753 [pool-1-thread-6] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-6 获取到许可证</span><br><span class="line">14:43:34.753 [pool-1-thread-5] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-5 获取到许可证</span><br><span class="line">14:43:35.056 [pool-1-thread-8] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-8 获取到许可证</span><br><span class="line">14:43:35.056 [pool-1-thread-9] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-9 获取到许可证</span><br><span class="line">14:43:35.056 [pool-1-thread-7] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-7 获取到许可证</span><br><span class="line">14:43:35.356 [pool-1-thread-10] INFO  c.g.thread.ThreadControlToolsTest - pool-1-thread-10 获取到许可证</span><br><span class="line">14:43:36.453 [main] INFO  c.g.thread.ThreadControlToolsTest - end</span><br></pre></td></tr></table></figure>

<h1 id="Semaphore源码"><a href="#Semaphore源码" class="headerlink" title="Semaphore源码"></a>Semaphore源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">public class Semaphore implements java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line"></span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        Sync(int permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getPermits() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int available = getState();</span><br><span class="line">                int remaining = available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int next = current + releases;</span><br><span class="line">                if (next &lt; current) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">                if (compareAndSetState(current, next))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void reducePermits(int reductions) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int next = current - reductions;</span><br><span class="line">                if (next &gt; current) // underflow</span><br><span class="line">                    throw new Error(&quot;Permit count underflow&quot;);</span><br><span class="line">                if (compareAndSetState(current, next))</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int drainPermits() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                if (current == 0 || compareAndSetState(current, 0))</span><br><span class="line">                    return current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = -2694183684443567898L;</span><br><span class="line"></span><br><span class="line">        NonfairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">        FairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                if (hasQueuedPredecessors())</span><br><span class="line">                    return -1;</span><br><span class="line">                int available = getState();</span><br><span class="line">                int remaining = available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Semaphore(int permits) &#123;</span><br><span class="line">        sync = new NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void acquire() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void acquireUninterruptibly() &#123;</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryAcquire() &#123;</span><br><span class="line">        return sync.nonfairTryAcquireShared(1) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void release() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void acquireUninterruptibly(int permits) &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        sync.acquireShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryAcquire(int permits) &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        return sync.nonfairTryAcquireShared(permits) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryAcquire(int permits, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void release(int permits) &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int availablePermits() &#123;</span><br><span class="line">        return sync.getPermits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int drainPermits() &#123;</span><br><span class="line">        return sync.drainPermits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void reducePermits(int reduction) &#123;</span><br><span class="line">        if (reduction &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        sync.reducePermits(reduction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFair() &#123;</span><br><span class="line">        return sync instanceof FairSync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public final int getQueueLength() &#123;</span><br><span class="line">        return sync.getQueueLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">        return sync.getQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%A2%E5%8D%95%E8%A1%A8%E6%8C%89%E7%85%A7%E8%AE%A2%E5%8D%95ID%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E-%E5%A6%82%E4%BD%95%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%A0%B9%E6%8D%AE%E5%88%AB%E7%9A%84%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张小二">
      <meta itemprop="description" content="夏天这么热能把暗恋变成热恋嘛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张小二的笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%A2%E5%8D%95%E8%A1%A8%E6%8C%89%E7%85%A7%E8%AE%A2%E5%8D%95ID%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E-%E5%A6%82%E4%BD%95%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%A0%B9%E6%8D%AE%E5%88%AB%E7%9A%84%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">面试题-订单表按照订单ID分库分表之后,如何高性能的根据别的字段进行查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-11 01:27:16" itemprop="dateCreated datePublished" datetime="2021-01-11T01:27:16+08:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 11:47:16" itemprop="dateModified" datetime="2022-07-16T11:47:16+08:00">2022-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天滴滴第三轮面试的时候, 遇到一道面试题, 大意是说现在给定一个订单表, 是按照订单ID来进行分库分表的, 那么如果想要根据订单的商户ID来进行查询某个商户的一些订单, 或者查询某个用户的订单, 该如何处理? 当时回答的不是很好, 后来询问了原来的同事, 发现可以通过Elasticsearch来构建二级索引或者干脆直接把全量数据存储在ES中的方式来处理分库分表之后的多条件查询以及JOIN查询</p>
<h1 id="Elasticsearch构建二级索引"><a href="#Elasticsearch构建二级索引" class="headerlink" title="Elasticsearch构建二级索引"></a>Elasticsearch构建二级索引</h1><p>可以将所需要的进行判断的字段, 简单理解也就是SQL语句中WHERE语句中进行判断的字段, 以及分库分表的分区字段, 在这道题中就是订单ID, 存储进Elasticsearch中. 构建一个二级索引, 每次查询的时候现在Elasticsearch中进行查询, 获取到订单ID, 然后再根据订单ID去MySQL执行查询就好了, 如果是聚合查询, 那么就需要自行在server中进行聚合</p>
<p>整个过程类似于MySQL中的非主键索引在执行非覆盖索引查询的时候, 执行的回表操作</p>
<h1 id="Elasticsearch存储全部字段"><a href="#Elasticsearch存储全部字段" class="headerlink" title="Elasticsearch存储全部字段"></a>Elasticsearch存储全部字段</h1><p>其实还可以将数据表的全部字段以及数据再存储一份到Elasticsearch, 查询的时候直接查询Elasticsearch中的数据就好了, 也不需要再查询数据库, 缺点是Elasticsearch中存储的数据会很多</p>
<h1 id="MySQL与Elsaticsearch中数据的增删改查如何保证事务"><a href="#MySQL与Elsaticsearch中数据的增删改查如何保证事务" class="headerlink" title="MySQL与Elsaticsearch中数据的增删改查如何保证事务?"></a>MySQL与Elsaticsearch中数据的增删改查如何保证事务?</h1><p>上面提到的是使用Elasticsearch构建MySQL二级索引的查询过程, 但是这中间还有一个问题, 就是Server在写入或者修改数据的时候, 如何保证MySQL与Elasticsearch修改的事务性. 也就是MySQL中执行了增删改的动作, Elasticsearch如何保证也同步的增删改等. 这个如果不能保证, 那么就会造成数据不一致的情况.</p>
<p>我们在代码中最直观的一种做法就是同步写入, 伪代码如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Transcational</span><br><span class="line">public void saveData() &#123;</span><br><span class="line">    ...</span><br><span class="line">    orderDAO.insert(data);</span><br><span class="line">    esClient.insert(data);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述的伪代码存在的问题就是, 事务性其实是不能得到保障的, 就算是先写MySQL, 然后写入ES, ES抛了异常导致MySQL回滚也不行, 我们在实际生产环境的代码没有伪代码这么简单, ES客户端的操作后面也可能还有业务逻辑, 这个saveData方法也有可能被别的事务调用, 所以这种方式其实是不行的.</p>
<h2 id="订阅binlog"><a href="#订阅binlog" class="headerlink" title="订阅binlog"></a>订阅binlog</h2><p>基于阿里巴巴开源的canal, 订阅MySQL的binlog, 把数据近实时同步到Elasticsearch中, 写入到Elasticsearch的这个过程只需要保证at least onece就可以了, 在写入Elasticsearch时自行保证幂等性</p>
<p>canal地址: <a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="编程式事务-补偿"><a href="#编程式事务-补偿" class="headerlink" title="编程式事务+补偿"></a>编程式事务+补偿</h2><p>前面的伪代码采取的是声明式的方式, 无法保证回滚了MySQL数据之后Elasticsearch中的数据也能回滚, 可以采用编程式事务的方式来操作, 回滚了MySQL数据之后自行控制Elasticsearch的回滚</p>
<p>Elasticsearch集群也有可能发生问题或者故障, 为了避免Elasticsearch的问题导致整个业务的失败, JD的一篇文章提到一种做法, 每当Elasticsearch写入失败之后, 就把数据写入到MySQL中, 然后构建一个Worker任务定时扫描这些数据, 做补偿</p>
<p>JD的文章链接: <a target="_blank" rel="noopener" href="https://dbaplus.cn/news-11-2397-1.html">https://dbaplus.cn/news-11-2397-1.html</a></p>
<h2 id="使用消息队列同步更改数据库"><a href="#使用消息队列同步更改数据库" class="headerlink" title="使用消息队列同步更改数据库"></a>使用消息队列同步更改数据库</h2><p>我们还可以使用消息队列来传输数据的更改, 但是值得注意的是, 需要保证消息的有序消费, 构造同一行数据的增删改乱序, 也会导致数据错乱的问题出现</p>
<h1 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h1><p>上文提到的两种方案也有一些弊端</p>
<ol>
<li>数据不一致<ol>
<li>数据同步需要时间</li>
<li>数据写入到Elasticsearch之后, 保存进去的数据不能立即被查询到, 需要等待刷新周期(1s)</li>
</ol>
</li>
<li>如果借助的canal或者消息队列这种中间件出现故障, 还需要有降级的手段</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">张小二</p>
  <div class="site-description" itemprop="description">夏天这么热能把暗恋变成热恋嘛</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张小二</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
